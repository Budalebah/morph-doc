"use strict";(self.webpackChunkmorphism_doc=self.webpackChunkmorphism_doc||[]).push([[4515],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},d="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),p=o,m=d["".concat(s,".").concat(p)]||d[p]||h[p]||a;return n?r.createElement(m,i(i({ref:t},u),{},{components:n})):r.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:o,i[1]=l;for(var c=2;c<a;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},4246:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var r=n(7462),o=(n(7294),n(3905));const a={title:"Morphism Modular Design",lang:"en-US"},i=void 0,l={unversionedId:"How Morphism Works/archi",id:"How Morphism Works/archi",title:"Morphism Modular Design",description:"TL;DR",source:"@site/docs/How Morphism Works/2-archi.md",sourceDirName:"How Morphism Works",slug:"/How Morphism Works/archi",permalink:"/docs/How Morphism Works/archi",draft:!1,editUrl:"https://github.com/morphism-labs/morphism-doc/blob/main/docs/How Morphism Works/2-archi.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Morphism Modular Design",lang:"en-US"},sidebar:"HowSidebar",previous:{title:"Introduction",permalink:"/docs/How Morphism Works/howintro"},next:{title:"Decentralized Sequencers",permalink:"/docs/How Morphism Works/Decentralized Sequencers/"}},s={},c=[{value:"TL;DR",id:"tldr",level:2},{value:"Overview",id:"overview",level:2},{value:"L2 Node",id:"l2-node",level:3},{value:"Transactions Manager (Mempool)",id:"transactions-manager-mempool",level:3},{value:"Executor",id:"executor",level:3},{value:"Synchronizer",id:"synchronizer",level:3},{value:"Sequencers",id:"sequencers",level:3},{value:"Validator",id:"validator",level:3},{value:"Prover",id:"prover",level:3}],u={toc:c},d="wrapper";function h(e){let{components:t,...a}=e;return(0,o.kt)(d,(0,r.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"tldr"},"TL;DR"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Due to its improved composability, the modular design of blockchain has become a trend, and we have incorporated this design into the construction of Morphism."),(0,o.kt)("li",{parentName:"ol"},"The architectural design of Morphism can be divided into three parts: high-level consensus, execution, and state verification, which correspond to different functions."),(0,o.kt)("li",{parentName:"ol"},"Each part contains different components that can be combined in various ways to perform functions in different roles. Different roles also correspond to multiple components to maintain independence..")),(0,o.kt)("h2",{id:"overview"},"Overview"),(0,o.kt)("p",null,"A general Layer 2 workflow is as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Users send transactions to sequencers."),(0,o.kt)("li",{parentName:"ol"},"Sequencers receive the transactions, generate blocks, and execute them."),(0,o.kt)("li",{parentName:"ol"},"Transactions are put into batches and submitted to Layer 1 contracts for data availability.")),(0,o.kt)("p",null,"In addition to the basic workflow, Morphism aims to achieve a balance between decentralization, security, and scalability by implementing various measures, including:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Sequencers needing to reach consensus with each other before executing transactions."),(0,o.kt)("li",{parentName:"ul"},"Validators (any user that runs an L2 node) can start a challenge that requires sequencers to provide the zk proof."),(0,o.kt)("li",{parentName:"ul"},"Sequencers can call the zkProver to generate a validity proof.")),(0,o.kt)("p",null,"To achieve these features, we designed several modules:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"L1 Contracts")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Consensus Staking Contract"),(0,o.kt)("li",{parentName:"ol"},"Rollup Contracts"),(0,o.kt)("li",{parentName:"ol"},"ZK Proof Contract"),(0,o.kt)("li",{parentName:"ol"},"Challenge Contract"),(0,o.kt)("li",{parentName:"ol"},"Bridge Contract")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Sequencer",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Txns/State Submitter"),(0,o.kt)("li",{parentName:"ul"},"Consensus Module"),(0,o.kt)("li",{parentName:"ul"},"L2 Node"))),(0,o.kt)("li",{parentName:"ul"},"Full Node"),(0,o.kt)("li",{parentName:"ul"},"Validator"),(0,o.kt)("li",{parentName:"ul"},"Prover\nThe skeletal architecture of Morphism is shown below:\n",(0,o.kt)("img",{alt:"arichitecture",src:n(5510).Z,width:"1358",height:"1368"}))),(0,o.kt)("h3",{id:"l2-node"},"L2 Node"),(0,o.kt)("p",null,"L2 node plays a pivotal role in overall architecture design, serving as a hub for multiple other modules to interact and exchange information through. Various roles require L2 node as an integral part of their normal operation."),(0,o.kt)("p",null,"L2 node itself is also divided into different components, each with its own specific function:"),(0,o.kt)("h3",{id:"transactions-manager-mempool"},"Transactions Manager (Mempool)"),(0,o.kt)("p",null,"The L2 node will use this component to manage all Layer 2 transactions, including:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Accepting user-initiated transactions and storing them in the Mempool"),(0,o.kt)("li",{parentName:"ol"},"Responding to the consensus layer by providing the latest transactions from the Mempool for block generation when certain conditions are met"),(0,o.kt)("li",{parentName:"ol"},"Recording and storing Layer 2 transactions.")),(0,o.kt)("h3",{id:"executor"},"Executor"),(0,o.kt)("p",null,"The L2 node will maintain the real-time status of Layer 2, and currently Morphism has made some modifications to Geth specifically for ZK-Proof, using it as the execution layer. After receiving consensus-approved blocks, the L2 node applies them to the current state to achieve state transition.\nBased on this logic, the execution layer ensures Ethereum compatibility and allows developers to have a consistent development experience."),(0,o.kt)("h3",{id:"synchronizer"},"Synchronizer"),(0,o.kt)("p",null,"There is often a need for synchronization between L2 nodes to restore network status, so the L2 node includes a synchronizer to synchronize data with each other. The frequency and functionality of synchronization vary depending on the role used. For example, for an L2 node running a sequencer, it will first synchronize blocks among various sequencers to achieve consensus, and then synchronize blocks to full nodes. As for full nodes, other roles in the network such as validator and prover will synchronize blocks from the full node to complete their work."),(0,o.kt)("h3",{id:"sequencers"},"Sequencers"),(0,o.kt)("p",null,"As the most important part of the network, sequencers serve the following functions:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Receiving Layer 2 users' transactions and form the block (L2 Node)"),(0,o.kt)("li",{parentName:"ol"},"Reach block consensus with other sequencers (Consensus)"),(0,o.kt)("li",{parentName:"ol"},"Excute blocks and apply state transmission (L2 Node)"),(0,o.kt)("li",{parentName:"ol"},"Batch the blocks and submit them to Layer 1 along with the new Layer 2 state ()"),(0,o.kt)("li",{parentName:"ol"},"Sync the blocks with full nodes"),(0,o.kt)("li",{parentName:"ol"},"Utilize provers to generate validity proof when being challenged")),(0,o.kt)("h3",{id:"validator"},"Validator"),(0,o.kt)("p",null,"Validator is a role that can be taken on by any user, and becoming a validator is completely permissionless. Validators need to determine whether the state submitted by the Sequencer to L1 is correct, and the best way to do this is to maintain an L2 Node that synchronizes transactions and state changes in L2.\nWhen a validator identifies an incorrect state, they can trigger a challenge by calling the contract's method, which will require the sequencer to generate and submit a zk proof for the challenged block."),(0,o.kt)("h3",{id:"prover"},"Prover"),(0,o.kt)("p",null,"Prover is an indispensable part of the Morphism architecture. When a sequencer is challenged by a validator, in order to prove its innocence, the sequencer needs to call the prover to generate zk proofs for the corresponding state change. "),(0,o.kt)("p",null,"The Prover module needs to maintain two components: L2 Node and zkEVM. It will synchronize the required Layer 2 transaction information through L2 Node and generate corresponding zk proofs through zkEVM component."),(0,o.kt)("p",null,"Under the current framework of Morphism, the prover is only called when the sequencer is challenged due to inefficient performance and high cost in generating zk proofs with current technology conditions. After relevant issues are properly resolved in the future, Morphism will be converted into a complete ZK Rollup that generates zk proof for each Layer 2 block."))}h.isMDXComponent=!0},5510:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/archi-282b054ede6f15d19526d71e00bf9408.png"}}]);