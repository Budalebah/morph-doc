"use strict";(self.webpackChunkmorph_doc=self.webpackChunkmorph_doc||[]).push([[2215],{9613:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(9496);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(n),m=r,u=p["".concat(l,".").concat(m)]||p[m]||h[m]||o;return n?a.createElement(u,i(i({ref:t},c),{},{components:n})):a.createElement(u,i({ref:t},c))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,i[1]=s;for(var d=2;d<o;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8492:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var a=n(8063),r=(n(9496),n(9613));const o={title:"Bridge between Morph and Ethereum",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimstic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!"},i=void 0,s={unversionedId:"build-on-morph/build-on-morph/bridge-between-morph-and-ethereum",id:"build-on-morph/build-on-morph/bridge-between-morph-and-ethereum",title:"Bridge between Morph and Ethereum",description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!",source:"@site/docs/build-on-morph/build-on-morph/3-bridge-between-morph-and-ethereum.md",sourceDirName:"build-on-morph/build-on-morph",slug:"/build-on-morph/build-on-morph/bridge-between-morph-and-ethereum",permalink:"/docs/build-on-morph/build-on-morph/bridge-between-morph-and-ethereum",draft:!1,editUrl:"https://github.com/morph-l2/morph-doc/tree/main/docs/build-on-morph/build-on-morph/3-bridge-between-morph-and-ethereum.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Bridge between Morph and Ethereum",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimstic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!"},sidebar:"DevSidebar",previous:{title:"Devlopement Setup",permalink:"/docs/build-on-morph/build-on-morph/development-setup"},next:{title:"Understand Transaction Cost on Morph",permalink:"/docs/build-on-morph/build-on-morph/understand-transaction-cost-on-morph"}},l={},d=[{value:"Bridging basics",id:"bridging-basics",level:2},{value:"Sending tokens",id:"sending-tokens",level:3},{value:"Sending data",id:"sending-data",level:3},{value:"Utilize Standard Bridge Contract",id:"utilize-standard-bridge-contract",level:2},{value:"Deposits",id:"deposits",level:2},{value:"Depositing ERC20s",id:"depositing-erc20s",level:3},{value:"Depositing ETH",id:"depositing-eth",level:3},{value:"Withdrawals",id:"withdrawals",level:2},{value:"Withdrawing ERC20s",id:"withdrawing-erc20s",level:3},{value:"Withdrawing ETH",id:"withdrawing-eth",level:3},{value:"Send messages between Morph and Ethereum",id:"send-messages-between-morph-and-ethereum",level:2},{value:"Communication basics between layers",id:"communication-basics-between-layers",level:3},{value:"Fees for L2 \u21d2 L1 transactions",id:"fees-for-l2--l1-transactions",level:3},{value:"Understanding the challenge period",id:"understanding-the-challenge-period",level:3}],c={toc:d},p="wrapper";function h(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"bridging-basics"},"Bridging basics"),(0,r.kt)("p",null,"Although Morph is an Ethereum Layer 2 (and therefore fundamentally connected to Ethereum), it's also a separate blockchain system. "),(0,r.kt)("p",null,'App developers often have a need to move data and assets between Morph and Ethereum, a process we call "bridging".'),(0,r.kt)("h3",{id:"sending-tokens"},"Sending tokens"),(0,r.kt)("p",null,"For the most common usecase, moving tokens around, we've created ",(0,r.kt)("a",{parentName:"p",href:"#using-the-standard-bridge"},"the Standard Token Bridge"),". The Standard Token Bridge is a simple smart contract with all the functionality you need to move tokens between Morph and Ethereum. It also allows you to easily create L2 representations of existing tokens on Ethereum."),(0,r.kt)("h3",{id:"sending-data"},"Sending data"),(0,r.kt)("p",null,"If the Standard Token Bridge doesn't fully cover your usecase, you can also ",(0,r.kt)("a",{parentName:"p",href:"#send-messages-between-morph-and-ethereum"},"send arbitrary data between L1 and L2"),". You can use this functionality to have a contract on Ethereum trigger a contract function on Morph, and vice versa. "),(0,r.kt)("p",null,"We've made this process as easy as possible by giving developers a simple API for triggering a cross-chain function call. "),(0,r.kt)("h2",{id:"utilize-standard-bridge-contract"},"Utilize Standard Bridge Contract"),(0,r.kt)("p",null,'To facilitate common interactions like transferring ETH and ERC20 tokens between the two networks, we offer the "Standard Bridge". This bridge simplifies the transfer of assets between L1 and L2.'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},'Standard Bridge Functionality: It allows for ETH or ERC20 token to be deposited on L1 and locked in exchange for an equivalent amount on L2, and vice versa. This is known as "bridging a token," e.g., depositing 100 USDC on L1 for 100 USDC on L2. .')),(0,r.kt)("p",null,"The Standard Bridge is composed of two main contracts the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/morph-l2/contracts/tree/main/contracts/L1/L1StandardBridge.sol"},(0,r.kt)("inlineCode",{parentName:"a"},"L1StandardBridge"))," (for Layer 1) and the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/morph-l2/contracts/tree/main/contracts/L2/L2StandardBridge.sol"},(0,r.kt)("inlineCode",{parentName:"a"},"L2StandardBridge"))," (for Layer 2)."),(0,r.kt)("p",null,"Here we'll go over the basics of using this bridge to move tokens between Layer 1 and Layer 2."),(0,r.kt)("h2",{id:"deposits"},"Deposits"),(0,r.kt)("h3",{id:"depositing-erc20s"},"Depositing ERC20s"),(0,r.kt)("p",null,"ERC20 deposits into L2 can be triggered via the ",(0,r.kt)("inlineCode",{parentName:"p"},"depositERC20")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"depositERC20To")," functions on the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/morph-l2/contracts/tree/main/contracts/L1/L1StandardBridge.sol"},(0,r.kt)("inlineCode",{parentName:"a"},"L1StandardBridge")),"."),(0,r.kt)("p",null,"Ensure the Standard Token Bridge is ",(0,r.kt)("strong",{parentName:"p"},"approved")," to use the tokens you wish to deposit."),(0,r.kt)("h3",{id:"depositing-eth"},"Depositing ETH"),(0,r.kt)("p",null,"ETH deposits into L2 can be triggered via the ",(0,r.kt)("inlineCode",{parentName:"p"},"depositETH")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"depositETHTo")," functions on the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/morph-l2/contracts/tree/main/contracts/L1/L1StandardBridge.sol#L119C20-L119C20"},(0,r.kt)("inlineCode",{parentName:"a"},"L1StandardBridge")),".\nETH deposits can alternatively be triggered by sending ETH directly to the ",(0,r.kt)("inlineCode",{parentName:"p"},"L1StandardBridge"),".\nOnce your deposit is detected and finalized, your account will be funded with the corresponding amount of ETH on L2."),(0,r.kt)("h2",{id:"withdrawals"},"Withdrawals"),(0,r.kt)("h3",{id:"withdrawing-erc20s"},"Withdrawing ERC20s"),(0,r.kt)("p",null,"ERC20 withdrawals can be triggered via the ",(0,r.kt)("inlineCode",{parentName:"p"},"withdraw")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"withdrawTo")," functions on the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/morph-l2/contracts/tree/main/contracts/L2/L2StandardBridge.sol#L121"},(0,r.kt)("inlineCode",{parentName:"a"},"L2StandardBridge")),"."),(0,r.kt)("h3",{id:"withdrawing-eth"},"Withdrawing ETH"),(0,r.kt)("p",null,"Unlike on L1, we do not have a separate function on L2 for withdrawing ETH.\nInstead, you can use the ",(0,r.kt)("inlineCode",{parentName:"p"},"withdraw")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"withdrawTo")," functions on the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/morph-l2/contracts/tree/main/contracts/L2/L2StandardBridge.sol#L121"},(0,r.kt)("inlineCode",{parentName:"a"},"L2StandardBridge"))," and use the address ",(0,r.kt)("inlineCode",{parentName:"p"},"0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000")," as the L2 token address."),(0,r.kt)("h2",{id:"send-messages-between-morph-and-ethereum"},"Send messages between Morph and Ethereum"),(0,r.kt)("p",null,'Apps on Morph can be made to interact with apps on Ethereum via a process called "bridging".\nIn a nutshell, ',(0,r.kt)("strong",{parentName:"p"},"contracts on Morph can trigger contract functions on Ethereum, and vice versa"),".\nWith just a little bit of elbow grease, you also can create contracts that bridge the gap between Layer 1 and Layer 2!"),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"Understanding contract calls")),(0,r.kt)("p",null,"To understand the process of creating bridges between contracts on Layer 1 and Layer 2, you should first have a basic understanding of the way contracts on ",(0,r.kt)("em",{parentName:"p"},"Ethereum")," communicate with one another.\nIf you're a smart contract developer, you might be familiar with stuff like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"contract MyContract {\n    function doSomething(uint256 myFunctionParam) public {\n        // ... some sort of code goes here\n    }\n}\n\ncontract MyOtherContract {\n    function doTheThing(address myContractAddress, uint256 myFunctionParam) public {\n        MyContract(myContractAddress).doSomething(myFunctionParam);\n    }\n}\n")),(0,r.kt)("p",null,"Here, ",(0,r.kt)("inlineCode",{parentName:"p"},"MyOtherContract.doTheThing"),' triggers a "call" to ',(0,r.kt)("inlineCode",{parentName:"p"},"MyContract.doSomething"),'.\nA "call" is defined by a few key input parameters, mainly a ',(0,r.kt)("inlineCode",{parentName:"p"},"target address")," and some ",(0,r.kt)("inlineCode",{parentName:"p"},"calldata"),".\nIn this specific example, the ",(0,r.kt)("inlineCode",{parentName:"p"},"target address")," is going to be the address of our instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"MyContract"),".\nThe ",(0,r.kt)("inlineCode",{parentName:"p"},"calldata"),", on the other hand, depends on the function we're trying to call.\nSolidity uses an encoding scheme called ",(0,r.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.4/abi-spec.html"},"Contract ABI")," to both ",(0,r.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.4/abi-spec.html#function-selector"},"select which function to call")," and to ",(0,r.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.4/abi-spec.html#argument-encoding"},"encode function input arguments"),"."),(0,r.kt)("p",null,"Solidity gives us some useful tools to perform this same encoding manually.\nFor the sake of learning, let's take a look at how we can duplicate the same code with a manual encoding:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'contract MyContract {\n    function doSomething(uint256 myFunctionParam) public {\n        // ... some sort of code goes here\n    }\n}\n\ncontract MyOtherContract {\n    function doTheThing(address myContractAddress, uint256 myFunctionParam) public {\n        myContractAddress.call(\n            abi.encodeWithSignature(\n                "doSomething(uint256)",\n                myFunctionParam\n            )\n        );\n    }\n}\n')),(0,r.kt)("p",null,"Here we're using the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.4/units-and-global-variables.html#members-of-address-types"},'low-level "call" function')," and one of the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/v0.8.4/units-and-global-variables.html#abi-encoding-and-decoding-functions"},"ABI encoding functions built into Solidity"),"."),(0,r.kt)("p",null,"Although these two code snippets look a bit different, they're actually functionally identical.")),(0,r.kt)("h3",{id:"communication-basics-between-layers"},"Communication basics between layers"),(0,r.kt)("p",null,"At a high level, this process is pretty similar to the same process for two contracts on Ethereum (with a few caveats).\n",(0,r.kt)("strong",{parentName:"p"},'Communication between L1 and L2 is enabled by two special smart contracts called the "messengers"'),"."),(0,r.kt)("p",null,"Each layer has its own messenger contract which serves to abstract away some lower-level communication details, a lot like how HTTP libraries abstract away physical network connections."),(0,r.kt)("p",null,"We won't get into ",(0,r.kt)("em",{parentName:"p"},"too")," much detail about these contracts here \u2014 the only thing you really need to know about is the ",(0,r.kt)("inlineCode",{parentName:"p"},"sendMessage")," function attached to each messenger:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"function sendMessage(\n    address _target,\n    bytes memory _message,\n    uint32 _gasLimit\n) public;\n")),(0,r.kt)("p",null,"It's the same as that ",(0,r.kt)("inlineCode",{parentName:"p"},"call")," function used for contract messaging within L1 Ethereums.\nWe have an extra ",(0,r.kt)("inlineCode",{parentName:"p"},"_gasLimit")," field here, but ",(0,r.kt)("inlineCode",{parentName:"p"},"call")," has that too.\nThis is basically equivalent to:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"address(_target).call{gas: _gasLimit}(_message);\n")),(0,r.kt)("p",null,"Except, of course, that we're calling a contract on a completely different network."),(0,r.kt)("p",null,"We're glossing over a lot of the technical details that make this whole thing work under the hood.\nPoint is, it works.\nWant to call a contract on Morph from a contract on Ethereum?\nIt's dead simple:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},'// Pretend this is on L2\ncontract MyContract {\n    function doSomething(uint256 myFunctionParam) public {\n        // ... some sort of code goes here\n    }\n}\n\n// And pretend this is on L1\ncontract MyOtherContract {\n    function doTheThing(address myOptimisticContractAddress, uint256 myFunctionParam) public {\n        ovmL1CrossDomainMessenger.sendMessage(\n            myOptimisticContractAddress,\n            abi.encodeWithSignature(\n                "doSomething(uint256)",\n                myFunctionParam\n            ),\n            1000000 // use whatever gas limit you want\n        )\n    }\n}\n')),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Using the messenger contracts\nOur messenger contracts, the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/morph-l2/contracts/tree/main/contracts/L1/L1CrossDomainMessenger.sol"},(0,r.kt)("inlineCode",{parentName:"a"},"L1CrossDomainMessenger"))," and ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/morph-l2/contracts/tree/main/contracts/L2/L2CrossDomainMessenger.sol"},(0,r.kt)("inlineCode",{parentName:"a"},"L2CrossDomainMessenger")),", always come pre-deployed to each of our networks.")),(0,r.kt)("h3",{id:"fees-for-l2--l1-transactions"},"Fees for L2 \u21d2 L1 transactions"),(0,r.kt)("p",null,"Each message from L2 to L1 requires three transactions:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"An L2 transaction that ",(0,r.kt)("em",{parentName:"p"},"initiates")," the transaction, which is priced the same as any other transaction made on Morph.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"An L1 transaction that ",(0,r.kt)("em",{parentName:"p"},"proves")," the transaction.\nThis transaction can only be submitted after the state root is submitted to L1.\nThis transaction is expensive because it includes verifying a ",(0,r.kt)("a",{parentName:"p",href:"https://eth.wiki/fundamentals/patricia-tree"},"Merkle trie")," inclusion proof.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"An L1 transaction that ",(0,r.kt)("em",{parentName:"p"},"finalizes")," the transaction.\nThis transaction can only be submitted after the transaction challenge period has passed. "))),(0,r.kt)("p",null,"The total cost of an L2 to L1 transaction is therefore the combined cost of the L2 initialization transaction and the two L1 transactions."),(0,r.kt)("p",null,"The L1 proof and finalization transactions are typically significantly more expensive than the L2 initialization transaction."),(0,r.kt)("h3",{id:"understanding-the-challenge-period"},"Understanding the challenge period"),(0,r.kt)("p",null,"ne of the most important things to understand about L1 \u21d4 L2 interactions is that ",(0,r.kt)("strong",{parentName:"p"},"messages sent from Layer 2 to Layer 1 cannot be relayed during the challenge period"),"\n.\nThis means that any messages you send from Layer 2 will only be received on Layer 1 after this period has elapsed."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Read about Morph's unique challenge design based on ",(0,r.kt)("a",{parentName:"p",href:"/docs/how-morph-works/responsive-validity-proof/overview"},"Responsive validity proof"))),(0,r.kt)("p",null,'We call this period of time the "challenge period" because it is the time during which a transaction can be challenged.This period is critical for ensuring the integrity of transactions between Layer 2 and Layer 1.'),(0,r.kt)("p",null,"Comparing Rollup Approaches:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"In a basic Optimistic Rollup, identifying and correcting incorrect transactions or states (like a fraudulent withdrawal transaction aiming to redirect your ETH to a hacker's address) requires significant time and effort. This involves interactions with the sequencer to prove the transaction is incorrect."),(0,r.kt)("li",{parentName:"ul"},"Morph\u2019s approach differs. With Responsive Validity Proof, the sequencer is required to prove their correctness by submitting a zk (zero-knowledge) validity proof. This system necessitates a specific period for challengers to detect issues and initiate a challenge.")),(0,r.kt)("p",null,"Implications for Smart Contracts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"It\u2019s crucial not to make decisions about Layer 2 transaction results from within a smart contract on Layer 1 until the challenge period has elapsed. Doing so prematurely might lead to decisions based on invalid transaction results."),(0,r.kt)("li",{parentName:"ul"},"Consequently, messages sent from Layer 2 to Layer 1, using the standard messenger contracts, cannot be relayed until they have completed the full challenge period.")))}h.isMDXComponent=!0}}]);