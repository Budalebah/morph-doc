"use strict";(self.webpackChunkmorph_doc=self.webpackChunkmorph_doc||[]).push([[2274],{9613:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>m});var a=r(9496);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)r=o[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var l=a.createContext({}),h=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=h(e.components);return a.createElement(l.Provider,{value:t},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=h(r),u=n,m=d["".concat(l,".").concat(u)]||d[u]||p[u]||o;return r?a.createElement(m,i(i({ref:t},c),{},{components:r})):a.createElement(m,i({ref:t},c))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:n,i[1]=s;for(var h=2;h<o;h++)i[h]=r[h];return a.createElement.apply(null,i)}return a.createElement.apply(null,r)}u.displayName="MDXCreateElement"},8598:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>h});var a=r(8063),n=(r(9496),r(9613));const o={title:"Communication between Morph and Ethereum",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimstic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!"},i=void 0,s={unversionedId:"how-morph-works/general-protocol-design/communicate-between-morph-and-ethereum",id:"how-morph-works/general-protocol-design/communicate-between-morph-and-ethereum",title:"Communication between Morph and Ethereum",description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!",source:"@site/docs/how-morph-works/general-protocol-design/2-communicate-between-morph-and-ethereum.md",sourceDirName:"how-morph-works/general-protocol-design",slug:"/how-morph-works/general-protocol-design/communicate-between-morph-and-ethereum",permalink:"/docs/how-morph-works/general-protocol-design/communicate-between-morph-and-ethereum",draft:!1,editUrl:"https://github.com/morph-l2/morph-doc/tree/main/docs/how-morph-works/general-protocol-design/2-communicate-between-morph-and-ethereum.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Communication between Morph and Ethereum",lang:"en-US",keywords:["morph","ethereum","rollup","layer2","validity proof","optimstic zk-rollup"],description:"Upgrade your blockchain experience with Morph - the secure decentralized, cost0efficient, and high-performing optimstic zk-rollup solution. Try it now!"},sidebar:"HowSidebar",previous:{title:"Rollup",permalink:"/docs/how-morph-works/general-protocol-design/rollup"},next:{title:"Transactions Life Cycle",permalink:"/docs/how-morph-works/general-protocol-design/transactions-life-cycle"}},l={},h=[{value:"The Basic Idea of the Morph &lt;=&gt; Ethereum Bridge\u200b",id:"the-basic-idea-of-the-morph--ethereum-bridge",level:2},{value:"Deposit (L1 to L2 message)",id:"deposit-l1-to-l2-message",level:2},{value:"Construct a deposit request through Standard Bridge (Optional)",id:"construct-a-deposit-request-through-standard-bridge-optional",level:3},{value:"Pass the message through CrossDomainMessenger",id:"pass-the-message-through-crossdomainmessenger",level:3},{value:"Execute the message on Layer 2",id:"execute-the-message-on-layer-2",level:3},{value:"Withdraw (L2 -&gt; L1 message)",id:"withdraw-l2---l1-message",level:2},{value:"Withdraw Tree",id:"withdraw-tree",level:3},{value:"Verify the withdraw tree",id:"verify-the-withdraw-tree",level:3},{value:"Challenge Period",id:"challenge-period",level:3}],c={toc:h},d="wrapper";function p(e){let{components:t,...o}=e;return(0,n.kt)(d,(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("p",null,"Although Morph is a Layer 2 solution built atop Ethereum, it remains as a separate and distinct blockchain. Thus, it\u2019s essential to establish a communication channel between Morph and Ethereum to facilitate the smooth transfer of assets and messages. The communication can occur in two directions: from Ethereum to Morph and from Morph to Ethereum."),(0,n.kt)("h2",{id:"the-basic-idea-of-the-morph--ethereum-bridge"},"The Basic Idea of the Morph <=> Ethereum Bridge\u200b"),(0,n.kt)("p",null,'To transfer an asset between Ethereum and Morph, a user must lock the asset in the cross-layer bridge. When the lock is confirmed, Morph mints a Wrapped Token that reflects the value of the locked asset\u2013a process referred to as a "deposit".'),(0,n.kt)("p",null,'Once the minting is complete, a user or intended recipient can claim the asset in Morph. In the reverse scenario, the bridge can unlock the original asset on Ethereum by burning the Wrapped Token, a process called "withdraw".'),(0,n.kt)("p",null,"Furthermore, the bridge\u2019s utility extends beyond asset bridging, as token transfers operate under the same principle as message transfers. The bridge can, therefore, also facilitate cross-layer message bridging, allowing for data payloads to be transported between networks."),(0,n.kt)("h2",{id:"deposit-l1-to-l2-message"},"Deposit (L1 to L2 message)"),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Deposit Process",src:r(1424).Z,width:"902",height:"1302"})),(0,n.kt)("h3",{id:"construct-a-deposit-request-through-standard-bridge-optional"},"Construct a deposit request through Standard Bridge (Optional)"),(0,n.kt)("p",null,"A bridge request, whether it is for ETH, ERC20, or ERC721, is essentially a cross-chain message, which necessitates the initial construction of a message. Generally, the message structure remains consistent, especially for ETH & ERC20 token bridges."),(0,n.kt)("p",null,"Employing a standard bridge assembles a conventional token bridge message and relays it to the ",(0,n.kt)("inlineCode",{parentName:"p"},"CrossDomainMessenger")),(0,n.kt)("h3",{id:"pass-the-message-through-crossdomainmessenger"},"Pass the message through CrossDomainMessenger"),(0,n.kt)("p",null,"The `",(0,n.kt)("inlineCode",{parentName:"p"},"CrossDomainMessenger")," is the basic unit of cross-layer communication.\nThere are messenger contracts on both Layer 1 and Layer 2. For a deposit, the L1 messenger sends a message to the L2 messenger."),(0,n.kt)("p",null,"The interaction mirrors a contract call on Layer 1, which means custom messages (contract interactions) can be constructed to perform various types of cross-layer interactions."),(0,n.kt)("h3",{id:"execute-the-message-on-layer-2"},"Execute the message on Layer 2"),(0,n.kt)("p",null,"The cross-domain message is delivered to the ",(0,n.kt)("inlineCode",{parentName:"p"},"MophismPortal"),", which then triggers an event called ",(0,n.kt)("inlineCode",{parentName:"p"},"TransactionDeposited"),"."),(0,n.kt)("p",null,"The Sequencer will monitor this event and include a Layer 2 transaction in its next block."),(0,n.kt)("p",null,"A Layer 2 executor, holding the cross-chain message, interacts with the L2 messenger to execute the message, which may include transferring L2 ETH or ERC20 tokens to the recipient."),(0,n.kt)("h2",{id:"withdraw-l2---l1-message"},"Withdraw (L2 -> L1 message)"),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Withdraw Process",src:r(1682).Z,width:"1103",height:"1301"})),(0,n.kt)("p",null,"The withdrawal process is, in essence, the inverse of the deposit process, yet it has two main differences."),(0,n.kt)("h3",{id:"withdraw-tree"},"Withdraw Tree"),(0,n.kt)("p",null,"The action of withdrawal means interacting with L1 assets/contracts as a result of a Layer 2 transaction. Consequently, it\u2019s imperative to verify the existence of a Layer 2 transaction that triggers a withdrawal request in a manner that is verifiable on Layer 1."),(0,n.kt)("p",null,"To achieve this, we introduce a structure known as a Withdraw Tree, which records every L2 withdrawal transaction within a Merkel tree. Thus, a Merkel tree's characteristics can be leveraged to confirm the occurrence of a withdrawal request."),(0,n.kt)("p",null,"The term Withdraw Tree refers to an append-only Sparse Merkle Tree (SMT) whose leaf nodes record information on assets being transferred out of the network.\nA leaf within the Withdraw Tree is termed a Withdraw leaf. These withdraw leaves are classified into two types: type 0 for recording asset(s) information and type 1 for recording messaging information."),(0,n.kt)("p",null,"A withdraw leaf, in particular, is a Keccak256 hash of the ABI encoded packed structure with the following parameters:"),(0,n.kt)("p",null,"The Withdraw Tree is instrumental in cataloging withdrawal transactions and ascertaining the legitimacy of withdrawal requests.\nMorph has pre-deployed a Simple Merkle Tree contract dedicated to constructing the Layer 2 withdraw tree."),(0,n.kt)("p",null,"This tree incorporates three methods:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("inlineCode",{parentName:"li"},"getTreeroot")," - return current tree's root hash"),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("inlineCode",{parentName:"li"},"appendMessageHash")," - append a new leaf node to the tree"),(0,n.kt)("li",{parentName:"ol"},(0,n.kt)("inlineCode",{parentName:"li"},"verifyMerkleProof")," - verify if a leaf node existed in the tree (which means bridge request represented by the leaf is valid)")),(0,n.kt)("h3",{id:"verify-the-withdraw-tree"},"Verify the withdraw tree"),(0,n.kt)("p",null,"A withdrawal request on Layer 2 will culminate in the emission of an event. Our official bridge frontend and SDK provide a service that uses a Tree Prover to construct the appropriate Merkel proof."),(0,n.kt)("p",null,"Bridgers require this proof to invoke ",(0,n.kt)("inlineCode",{parentName:"p"},"proveWithdrawTransaction")," within the ",(0,n.kt)("inlineCode",{parentName:"p"},"MorphPortal")," contract to substantiate their withdrawal request. Once validated, the withdrawal request will be marked as proven and await finalization."),(0,n.kt)("h3",{id:"challenge-period"},"Challenge Period"),(0,n.kt)("p",null,"Additionally, because of the Optimistic zkEVM design, every transaction (including withdrawals) on Layer 2 must be submitted to Layer 1 and face a challenge period before finalization."),(0,n.kt)("p",null,"This process is vital to validate the Layer 2 state, including withdrawal transactions. The withdraw tree root, integral for withdrawal request verification, is also submitted by sequencers once the challenge period, batches, and states have been finalized."),(0,n.kt)("p",null,'If the withdrawal is proven and finalized, bridgers may then employ the "MorphPortal" to process the withdrawal on Layer 1.'))}p.isMDXComponent=!0},1424:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/deposit-255ef9906fc5bd5e93ed7b51d1de02c9.png"},1682:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/withdraw-a550ecf89d5c8d8aec0135f88da02148.png"}}]);